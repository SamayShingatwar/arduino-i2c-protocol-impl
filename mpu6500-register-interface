#include <Wire.h>

#define ICM_ADDR   0x68
#define WHO_AM_I   0x75
#define PWR_MGMT_1 0x6B

int16_t accl_x, accl_y, accl_z; // variables for accelerometer raw data
int16_t gyro_x, gyro_y, gyro_z; // variables for gyro raw data
int16_t temperature; // variable for temp data

char tmp_str[7]; //temporary variable used in the convert function for neatness
char* convert_int16_to_str(int16_t i){ //converts int16 to string. resulting strings will have same length in debug monitor 
  sprintf(tmp_str, "%6d", i);
  return tmp_str;
}

void setup() {
  Serial.begin(19200);
  Wire.begin();

  Wire.beginTransmission(ICM_ADDR);
  Wire.write(WHO_AM_I); //we are just pointing at the internal register, basically giving the internal addr to the device [IMU] to help us; we do not talk to internal registers.. just giving maibox addresses to the device to give us data from that particular addr
  Wire.endTransmission(false); //false stop means "i'm done giving orders, but don't hang up yet"; (repeated start condition) basically it keeps the communication line open/reserved for the current master.
  Wire.requestFrom(ICM_ADDR, 1, true); //requestFrom(addr, quantity, stop); quantity = #BYTES; 1 byte can store a number between 0-255 and since the register output for WHO_AM_I falls in that range, we use 1 byte of data;

  byte id = Wire.read(); 
  Serial.print("ID: 0x");
  Serial.println(id, HEX);

  if (id == 0x70) {
    Wire.beginTransmission(ICM_ADDR);
    Wire.write(PWR_MGMT_1); /*power 1 = mcb for a house and contrls the on/off for the whole chip, whereas power 2 is like individual room switches that can turn on/off individual components on the chip (like accelerometer, gyro, etc)*/
    Wire.write(0x00); // Wake up
    Wire.endTransmission();
    Serial.println("IMU Awake.");
  } else {
    Serial.println("Connection Failed.");
  }
}

void loop() {
Wire.beginTransmission(ICM_ADDR);
Wire.write(0x3B); // ACCEL_XOUT_H {starting register}
Wire.endTransmission(false); //restart condition so that the connection is alive
Wire.requestFrom(ICM_ADDR, 7*2, true); //requesting 7*2 = 14 registers

//"Wire.read()<<8 | Wire.read;" left bitwise operation, two registers are stored in the same variable
accl_x = Wire.read()<<8 | Wire.read();   // reading registers: 0x3B (ACCEL_XOUT_H) and 0x3C (ACCEL_XOUT_L)
accl_y = Wire.read()<<8 | Wire.read();   // reading registers: 0x3D (ACCEL_YOUT_H) and 0x3E (ACCEL_YOUT_L)
accl_z = Wire.read()<<8 | Wire.read();   // reading registers: 0x3F (ACCEL_ZOUT_H) and 0x40 (ACCEL_ZOUT_L)
temperature = Wire.read()<<8 | Wire.read();   // reading registers: 0x41 (TEMP_OUT_H) and 0x42 (TEMP_OUT_L)
gyro_x = Wire.read()<<8 | Wire.read();   // reading registers: 0x43 (GYRO_XOUT_H) and 0x44 (GYRO_XOUT_L)
gyro_y = Wire.read()<<8 | Wire.read();   // reading registers: 0x45 (GYRO_YOUT_H) and 0x46 (GYRO_YOUT_L)
gyro_z = Wire.read()<<8 | Wire.read();   // reading registers: 0x47 (GYRO_ZOUT_H) and 0x48 (GYRO_ZOUT_L)

//print out data on serial monitor
Serial.print("aX = "); Serial.print(convert_int16_to_str(accl_x));
Serial.print(" | aY = "); Serial.print(convert_int16_to_str(accl_y));
Serial.print(" | aZ = "); Serial.print(convert_int16_to_str(accl_z));
Serial.print(" | tmp = "); Serial.print(temperature/340.00 + 36.53);
Serial.print(" | gX = "); Serial.print(convert_int16_to_str(gyro_x));
Serial.print(" | gY = "); Serial.print(convert_int16_to_str(gyro_y));
Serial.print(" | gZ = "); Serial.print(convert_int16_to_str(gyro_z));
Serial.println();

}
